#!/usr/bin/env python3
import os
import json
from datetime import datetime

def _read(p):
    with open(p, "r", encoding="utf-8") as f:
        return f.read()

def _write(p, s):
    with open(p, "w", encoding="utf-8") as f:
        f.write(s)

def main():
    path = "app.py"
    if not os.path.exists(path):
        raise SystemExit("app.py not found in current directory")

    src = _read(path)

    needle_start = '@mcp.tool(\n    name="news_digest"'
    i = src.find(needle_start)
    if i < 0:
        raise SystemExit("cannot find news_digest block start")

    needle_end = 'def _news__norm_host'
    j = src.find(needle_end, i)
    if j < 0:
        raise SystemExit("cannot find news_digest block end (def _news__norm_host)")

    new_block = json.loads(NEW_BLOCK_JSON).rstrip("\n") + "\n"

    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    bak = "app.py.bak.news_miniflux_v2_{0}".format(ts)
    _write(bak, src)

    out = src[:i] + new_block + src[j:]
    _write(path, out)

    print("OK: patched news_digest (miniflux v2).")
    print("Backup:", bak)
    print("Changed range:", i, j)

NEW_BLOCK_JSON = "".join([
    '"@mcp.tool(\\n    name=\\"news_digest\\",\\n    description=\\"(Tool) News digest via Miniflux (RSS). Reads entries from the last 24 hours (rolling 24h). Category-driven; default 5 items. Chinese-first with lightweight topic filtering and fallback.\\"\\n)\\ndef news_digest(category: str = \\"world\\",\\n               limit: int = 5,\\n               time_range: str = \\"24h\\",\\n               prefer_lang: str = \\"zh\\",\\n               user_text: str = \\"\\",\\n               **kwargs) -> dict:\\n    \\"\\"\\"\\n    Miniflux-backed news digest.\\n\\n    Hard rules:\\n    - Source of truth: Miniflux (RSS aggregator)\\n    - Window: last 24 hours (rolling 24h), regardless of time_range input\\n    - Output: default 5 items, Chinese-first; if not enough, fallback to English\\n    - Lightweight topic filter to reduce category pollution:\\n        * blacklist keywords -> drop\\n        * whitelist keywords (when available) -> keep if hit, otherwise filtered\\n        * if filtered results not enough -> relax whitelist, then cross-language fill\\n    \\"\\"\\"\\n\\n    # ---- helpers / env ----\\n    base_url = os.environ.get(\\"MINIFLUX_BASE_URL\\") or \\"http://192.168.1.162:19091\\"\\n    token = os.environ.get(\\"MINIFLUX_API_TOKEN\\") or \\"\\"\\n    if not token.strip():\\n        return {\\n            \\"ok\\": False,\\n            \\"error\\": \\"MINIFLUX_API_TOKEN is not set\\",\\n            \\"category\\": category,\\n            \\"time_range\\": \\"24h\\",\\n            \\"limit\\": limit,\\n            \\"items\\": [],\\n            \\"final\\": \\"Miniflux API Token 未配置（MINIFLUX_API_TOKEN）。\\"\\n        }\\n\\n    def _mf_req(path: str, params: dict | None = None) -> dict:\\n        url = base_url.rstrip(\\"/\\") + path\\n        headers = {\\"X-Auth-Token\\": token}\\n        try:\\n            r = requests.get(url, headers=headers, params=(params or {}), timeout=12)\\n            if int(getattr(r, \\"status_code\\", 0) or 0) >= 400:\\n                return {\\"ok\\": False, \\"status\\": int(r.status_code), \\"text\\": (r.text or \\"\\")[:500]}\\n            return {\\"ok\\": True, \\"data\\": r.json()}\\n        except Exception as e:\\n            return {\\"ok\\": False, \\"error\\": str(e)}\\n\\n    def _strip_html(s: str) -> str:\\n        if not s:\\n            return \\"\\"\\n        try:\\n            s2 = re.sub(r\\"<[^>]+>\\", \\" \\", s)\\n            s2 = html.unescape(s2)\\n            s2 = re.sub(r\\"\\\\s+\\", \\" \\", s2).strip()\\n            return s2\\n        except Exception:\\n            return (s or \\"\\").strip()\\n\\n    def _to_local_time(iso_str: str) -> str:\\n        if not iso_str:\\n            return \\"\\"\\n        try:\\n            dt = datetime.fromisoformat(iso_str.replace(\\"Z\\", \\"+00:00\\"))\\n            tzname = os.environ.get(\\"TZ\\") or \\"Australia/Melbourne\\"\\n            dt2 = dt.astimezone(ZoneInfo(tzname))\\n            return dt2.strftime(\\"%Y-%m-%d %H:%M\\")\\n        except Exception:\\n            return iso_str\\n\\n    def _has_cjk(s: str) -> bool:\\n        if not s:\\n            return False\\n        try:\\n            han = 0\\n            total = 0\\n            for ch in s:\\n                oc = ord(ch)\\n                if ch.isspace():\\n                    continue\\n                total += 1\\n                if (0x4E00 <= oc <= 0x9FFF) or (0x3400 <= oc <= 0x4DBF) or (0x20000 <= oc <= 0x2A6DF):\\n                    han += 1\\n            if total <= 0:\\n                return False\\n            if han >= 8:\\n                return True\\n            return (float(han) / float(total)) >= 0.12\\n        except Exception:\\n            return False\\n\\n    def _kw_hit(text_s: str, kws: list) -> bool:\\n        if not text_s:\\n            return False\\n        t0 = (text_s or \\"\\").lower()\\n        for k in (kws or []):\\n            kk = (k or \\"\\").strip().lower()\\n            if not kk:\\n                continue\\n            if kk in t0:\\n                return True\\n        return False\\n\\n    def _norm_title(s: str) -> str:\\n        s2 = _ug_clean_unicode(s or \\"\\")\\n        s2 = s2.lower()\\n        s2 = re.sub(r\\"\\\\s+\\", \\" \\", s2).strip()\\n        return s2\\n\\n    cats = _mf_req(\\"/v1/categories\\")\\n    if not cats.get(\\"ok\\"):\\n        return {\\n            \\"ok\\": False,\\n            \\"error\\": \\"failed to fetch miniflux categories\\",\\n            \\"detail\\": cats,\\n            \\"category\\": category,\\n            \\"time_range\\": \\"24h\\",\\n            \\"limit\\": limit,\\n            \\"items\\": [],\\n            \\"final\\": \\"Miniflux categories 拉取失败。\\"\\n        }\\n\\n    categories = cats.get(\\"data\\") or []\\n    key = (category or \\"\\").strip()\\n\\n    aliases_map = {\\n        \\"world\\": [\\"world（世界新闻）\\", \\"世界新闻\\", \\"国际\\"],\\n        \\"cn_finance\\": [\\"cn_finance（中国财经）\\", \\"中国财经\\", \\"财经\\", \\"中国经济\\"],\\n        \\"au_politics\\": [\\"au_politics（澳洲政治新闻）\\", \\"澳洲政治\\", \\"澳大利亚政治\\", \\"Australian politics\\"],\\n        \\"mel_life\\": [\\"mel_life（墨尔本民生）\\", \\"墨尔本民生\\", \\"维州民生\\", \\"Victoria\\"],\\n        \\"tech_internet\\": [\\"tech_internet（互联网科技）\\", \\"互联网科技\\", \\"科技\\", \\"Tech\\"],\\n        \\"tech_gadgets\\": [\\"tech_gadgets（数码产品）\\", \\"数码产品\\", \\"评测\\", \\"Gadgets\\"],\\n        \\"gaming\\": [\\"gaming（电子游戏）\\", \\"电子游戏\\", \\"游戏\\", \\"Gaming\\"],\\n    }\\n\\n    def _match_cat_id(k: str):\\n        if not k:\\n            return None\\n        for c in categories:\\n            try:\\n                title = (c.get(\\"title\\") or \\"\\").strip()\\n                if title == k:\\n                    return int(c.get(\\"id\\"))\\n            except Exception:\\n                continue\\n        for c in categories:\\n            try:\\n                title = (c.get(\\"title\\") or \\"\\").strip()\\n                if title.startswith(k) or (k in title):\\n                    return int(c.get(\\"id\\"))\\n            except Exception:\\n                continue\\n        for al in (aliases_map.get(k) or []):\\n            for c in categories:\\n                try:\\n                    title = (c.get(\\"title\\") or \\"\\").strip()\\n                    if (al in title) or title == al:\\n                        return int(c.get(\\"id\\"))\\n                except Exception:\\n                    continue\\n        return None\\n\\n    cat_id = _match_cat_id(key)\\n    if cat_id is None:\\n        return {\\n            \\"ok\\": True,\\n            \\"category\\": key,\\n            \\"time_range\\": \\"24h\\",\\n            \\"limit\\": limit,\\n            \\"items\\": [],\\n            \\"final\\": \\"Miniflux 中找不到对应分类：{0}\\".format(key),\\n            \\"query_used\\": \\"miniflux categories title match\\"\\n        }\\n\\n    FILTERS = {\\n        \\"world\\": {\\n            \\"whitelist\\": [],\\n            \\"blacklist\\": [\\"ufc\\", \\"mma\\", \\"boxing odds\\", \\"celebrity gossip\\", \\"porn\\", \\"onlyfans\\"],\\n        },\\n        \\"cn_finance\\": {\\n            \\"whitelist\\": [\\"财经\\", \\"经济\\", \\"金融\\", \\"股\\", \\"a股\\", \\"港股\\", \\"美股\\", \\"债\\", \\"基金\\", \\"利率\\", \\"通胀\\", \\"人民币\\", \\"央行\\", \\"证监\\", \\"bank\\", \\"stocks\\", \\"market\\", \\"bond\\", \\"yields\\", \\"cpi\\", \\"gdp\\"],\\n            \\"blacklist\\": [\\"ufc\\", \\"mma\\", \\"赛后\\", \\"足球\\", \\"篮球\\", \\"综艺\\", \\"八卦\\", \\"明星\\", \\"电影\\", \\"电视剧\\"],\\n        },\\n        \\"au_politics\\": {\\n            \\"whitelist\\": [\\"parliament\\", \\"senate\\", \\"house\\", \\"election\\", \\"labor\\", \\"coalition\\", \\"liberal\\", \\"greens\\", \\"albanese\\", \\"dutton\\", \\"budget\\", \\"treasury\\", \\"immigration\\", \\"visa\\", \\"minister\\", \\"cabinet\\", \\"议会\\", \\"选举\\", \\"工党\\", \\"自由党\\", \\"绿党\\", \\"预算\\", \\"内阁\\", \\"移民\\", \\"签证\\"],\\n            \\"blacklist\\": [\\"ufc\\", \\"mma\\", \\"sport\\", \\"match preview\\", \\"odds\\", \\"celebrity\\"],\\n        },\\n        \\"mel_life\\": {\\n            \\"whitelist\\": [\\"melbourne\\", \\"victoria\\", \\"vic\\", \\"cbd\\", \\"ptv\\", \\"metro\\", \\"tram\\", \\"train\\", \\"bus\\", \\"police\\", \\"fire\\", \\"ambulance\\", \\"road\\", \\"freeway\\", \\"yarra\\", \\"docklands\\", \\"st kilda\\", \\"墨尔本\\", \\"维州\\", \\"本地\\", \\"民生\\", \\"交通\\", \\"电车\\", \\"火车\\", \\"警方\\", \\"火警\\", \\"道路\\"],\\n            \\"blacklist\\": [\\"ufc\\", \\"mma\\", \\"celebrity\\", \\"gossip\\", \\"crypto shill\\"],\\n        },\\n        \\"tech_internet\\": {\\n            \\"whitelist\\": [\\"ai\\", \\"openai\\", \\"google\\", \\"microsoft\\", \\"meta\\", \\"apple\\", \\"amazon\\", \\"tiktok\\", \\"x.com\\", \\"twitter\\", \\"github\\", \\"open source\\", \\"linux\\", \\"android\\", \\"ios\\", \\"cloud\\", \\"security\\", \\"privacy\\", \\"regulation\\", \\"chip\\", \\"semiconductor\\", \\"人工智能\\", \\"开源\\", \\"网络安全\\", \\"隐私\\", \\"监管\\", \\"芯片\\", \\"半导体\\"],\\n            \\"blacklist\\": [\\"ufc\\", \\"mma\\", \\"crime\\", \\"murder\\", \\"celebrity\\", \\"gossip\\", \\"lottery\\", \\"horoscope\\"],\\n        },\\n        \\"tech_gadgets\\": {\\n            \\"whitelist\\": [\\"review\\", \\"hands-on\\", \\"launch\\", \\"iphone\\", \\"ipad\\", \\"mac\\", \\"samsung\\", \\"pixel\\", \\"camera\\", \\"laptop\\", \\"headphones\\", \\"oled\\", \\"cpu\\", \\"gpu\\", \\"benchmark\\", \\"评测\\", \\"上手\\", \\"新品\\", \\"发布\\", \\"开箱\\", \\"相机\\", \\"手机\\", \\"耳机\\", \\"笔记本\\"],\\n            \\"blacklist\\": [\\"ufc\\", \\"mma\\", \\"crime\\", \\"celebrity\\", \\"gossip\\"],\\n        },\\n        \\"gaming\\": {\\n            \\"whitelist\\": [\\"game\\", \\"gaming\\", \\"steam\\", \\"playstation\\", \\"ps5\\", \\"xbox\\", \\"nintendo\\", \\"switch\\", \\"pc gamer\\", \\"patch\\", \\"update\\", \\"dlc\\", \\"release\\", \\"trailer\\", \\"esports\\", \\"游戏\\", \\"主机\\", \\"更新\\", \\"补丁\\", \\"发售\\", \\"预告\\", \\"steam\\"],\\n            \\"blacklist\\": [\\"ufc\\", \\"mma\\", \\"boxing\\", \\"wwe\\", \\"football\\", \\"basketball\\", \\"cricket\\", \\"horse racing\\"],\\n        },\\n    }\\n\\n    import time as _time\\n    after_ts = int(_time.time()) - 24 * 3600\\n\\n    try:\\n        lim_int = int(limit)\\n    except Exception:\\n        lim_int = 5\\n    if lim_int < 1:\\n        lim_int = 1\\n    if lim_int > 10:\\n        lim_int = 10\\n\\n    fetch_lim = lim_int * 6\\n    if fetch_lim < 20:\\n        fetch_lim = 20\\n    if fetch_lim > 80:\\n        fetch_lim = 80\\n\\n    params = {\\n        \\"order\\": \\"published_at\\",\\n        \\"direction\\": \\"desc\\",\\n        \\"limit\\": fetch_lim,\\n        \\"after\\": after_ts,\\n    }\\n\\n    ent = _mf_req(\\"/v1/categories/{0}/entries\\".format(cat_id), params=params)\\n    if not ent.get(\\"ok\\"):\\n        return {\\n            \\"ok\\": False,\\n            \\"error\\": \\"failed to fetch entries\\",\\n            \\"detail\\": ent,\\n            \\"category\\": key,\\n            \\"time_range\\": \\"24h\\",\\n            \\"limit\\": lim_int,\\n            \\"items\\": [],\\n            \\"final\\": \\"Miniflux entries 拉取失败。\\"\\n        }\\n\\n    payload = ent.get(\\"data\\") or {}\\n    entries = payload.get(\\"entries\\") or []\\n\\n    if not entries:\\n        return {\\n            \\"ok\\": True,\\n            \\"category\\": key,\\n            \\"time_range\\": \\"24h\\",\\n            \\"limit\\": lim_int,\\n            \\"items\\": [],\\n            \\"final\\": \\"暂无符合最近24小时的条目。\\",\\n            \\"query_used\\": \\"miniflux category_id={0} after={1}\\".format(cat_id, after_ts),\\n        }\\n\\n    all_items = []\\n    for e in entries:\\n        try:\\n            title = (e.get(\\"title\\") or \\"\\").strip()\\n            url = (e.get(\\"url\\") or \\"\\").strip() or (e.get(\\"comments_url\\") or \\"\\").strip()\\n            published_at_raw = (e.get(\\"published_at\\") or \\"\\").strip()\\n            published_at = _to_local_time(published_at_raw)\\n            feed = e.get(\\"feed\\") or {}\\n            src = (feed.get(\\"title\\") or \\"\\").strip()\\n            content_plain = _strip_html((e.get(\\"content\\") or \\"\\").strip())\\n            snippet = content_plain\\n            if len(snippet) > 180:\\n                snippet = snippet[:180].rstrip() + \\"...\\"\\n            is_zh = _has_cjk((title or \\"\\") + \\" \\" + (content_plain or \\"\\"))
            all_items.append({\\n                \\"title\\": title,\\n                \\"url\\": url,\\n                \\"published_at\\": published_at,\\n                \\"published_at_raw\\": published_at_raw,\\n                \\"source\\": src,\\n                \\"snippet\\": snippet,\\n                \\"is_zh\\": is_zh,\\n                \\"content_plain\\": content_plain,\\n            })\\n        except Exception:\\n            continue\\n\\n    cfg = FILTERS.get(key) or {\\n        \\"whitelist\\": [],\\n        \\"blacklist\\": []\\n    }\\n    wl = cfg.get(\\"whitelist\\") or []\\n    bl = cfg.get(\\"blacklist\\") or []\\n\\n    def _passes_blacklist(it: dict) -> bool:\\n        txt = \\"{0} {1} {2}\\".format(it.get(\\"title\\") or \\"\\", it.get(\\"snippet\\") or \\"\\", it.get(\\"source\\") or \\"\\")\\n        return (not _kw_hit(txt, bl))\\n\\n    def _passes_whitelist(it: dict) -> bool:\\n        if not wl:\\n            return True\\n        txt = \\"{0} {1}\\".format(it.get(\\"title\\") or \\"\\", it.get(\\"snippet\\") or \\"\\")\\n        return _kw_hit(txt, wl)\\n\\n    def _pick(items_in: list, require_wl: bool, need: int, picked: list, seen_titles: set):\\n        if need <= 0:\\n            return\\n        for it in (items_in or []):\\n            if need <= 0:\\n                break\\n            if not isinstance(it, dict):\\n                continue\\n            if not _passes_blacklist(it):\\n                continue\\n            if require_wl and (not _passes_whitelist(it)):\\n                continue\\n            nt = _norm_title(it.get(\\"title\\") or \\"\\")\\n            if nt and nt in seen_titles:\\n                continue\\n            seen_titles.add(nt)\\n            picked.append(it)\\n            need -= 1\\n\\n    prefer = (prefer_lang or \\"zh\\").strip().lower()\\n    if prefer not in [\\"zh\\", \\"en\\"]:\\n        prefer = \\"zh\\"\\n\\n    zh_items = [x for x in all_items if bool(x.get(\\"is_zh\\"))]\\n    en_items = [x for x in all_items if not bool(x.get(\\"is_zh\\"))]\\n\\n    picked = []\\n    seen = set()\\n\\n    if prefer == \\"zh\\":\\n        _pick(zh_items, True, lim_int - len(picked), picked, seen)\\n        _pick(en_items, True, lim_int - len(picked), picked, seen)\\n    else:\\n        _pick(en_items, True, lim_int - len(picked), picked, seen)\\n        _pick(zh_items, True, lim_int - len(picked), picked, seen)\\n\\n    if len(picked) < lim_int:\\n        if prefer == \\"zh\\":\\n            _pick(zh_items, False, lim_int - len(picked), picked, seen)\\n            _pick(en_items, False, lim_int - len(picked), picked, seen)\\n        else:\\n            _pick(en_items, False, lim_int - len(picked), picked, seen)\\n            _pick(zh_items, False, lim_int - len(picked), picked, seen)\\n\\n    if len(picked) < lim_int:\\n        for it in all_items:\\n            if len(picked) >= lim_int:\\n                break\\n            nt = _norm_title(it.get(\\"title\\") or \\"\\")\\n            if nt and nt in seen:\\n                continue\\n            seen.add(nt)\\n            picked.append(it)\\n\\n    out_items = picked[:lim_int]\\n\\n    lines = []\\n    for i, it in enumerate(out_items, 1):\\n        t = it.get(\\"title\\") or \\"\\"\\n        u = it.get(\\"url\\") or \\"\\"\\n        src = it.get(\\"source\\") or \\"\\"\\n        pa = it.get(\\"published_at\\") or \\"\\"\\n        sn = it.get(\\"snippet\\") or \\"\\"\\n        lines.append(\\"{0}) {1}\\".format(i, t))\\n        meta = []\\n        if src:\\n            meta.append(src)\\n        if pa:\\n            meta.append(pa)\\n        if meta:\\n            lines.append(\\"   [{0}]\\\".format(\\" | \\".join(meta)))\\n        if sn:\\n            lines.append(\\"   {0}\\".format(sn))\\n        if u:\\n            lines.append(\\"   {0}\\".format(u))\\n\\n    return {\\n        \\"ok\\": True,\\n        \\"category\\": key,\\n        \\"time_range\\": \\"24h\\",\\n        \\"limit\\": lim_int,\\n        \\"items\\": out_items,\\n        \\"final\\": \\"\\\\n\\".join(lines).strip(),\\n        \\"query_used\\": \\"miniflux category_id={0} after={1} fetch_limit={2}\\".format(cat_id, after_ts, fetch_lim),\\n        \\"stats\\": {\\n            \\"fetched\\": len(all_items),\\n            \\"zh_fetched\\": len(zh_items),\\n            \\"en_fetched\\": len(en_items),\\n            \\"returned\\": len(out_items),\\n        },\\n    }\\n"',  # NOTE: 如果你想让我把这段 NEW_BLOCK_JSON 彻底做成“可读版本”，我会在你下一条消息里给你一份不压缩的脚本（这里先按“可直接跑”为优先）
])

if __name__ == "__main__":
    main()
