from pathlib import Path

p = Path("app.py")
s = p.read_text(encoding="utf-8")

MARK_HELPER_BEGIN = "# --- WEATHER_RANGE_V1 HELPERS BEGIN ---"
MARK_HELPER_END   = "# --- WEATHER_RANGE_V1 HELPERS END ---"
MARK_ROUTE_BEGIN  = "# --- WEATHER_RANGE_V1 ROUTE BEGIN ---"
MARK_ROUTE_END    = "# --- WEATHER_RANGE_V1 ROUTE END ---"

# ---------- 1) insert helpers (idempotent) ----------
if MARK_HELPER_BEGIN not in s:
    # put helpers near calendar range parser if possible; fallback: before route_request
    anchor = "def _calendar_range_from_text"
    i = s.find(anchor)
    if i < 0:
        anchor2 = "def route_request"
        i = s.find(anchor2)
        if i < 0:
            raise RuntimeError("cannot find anchor to insert weather helpers")

    helpers = (
MARK_HELPER_BEGIN + "\n"
"def _local_date_from_iso(dt_str: str, tzinfo) -> date:\n"
"    try:\n"
"        if not dt_str:\n"
"            return None\n"
"        dtx = datetime.fromisoformat(str(dt_str).replace('Z', '+00:00'))\n"
"        if getattr(dtx, 'tzinfo', None) is None:\n"
"            try:\n"
"                dtx = dtx.replace(tzinfo=tzinfo)\n"
"            except Exception:\n"
"                pass\n"
"        try:\n"
"            dtx2 = dtx.astimezone(tzinfo)\n"
"        except Exception:\n"
"            dtx2 = dtx\n"
"        return date(dtx2.year, dtx2.month, dtx2.day)\n"
"    except Exception:\n"
"        return None\n"
"\n"
"def _weather_range_from_text(t: str) -> dict:\n"
"    # Supports: today/tomorrow/后天, next N days, explicit date, date range\n"
"    now = _now_local()\n"
"    text = (t or '').strip()\n"
"    low = text.lower()\n"
"    base_d = date(now.year, now.month, now.day)\n"
"\n"
"    def _clamp_int(v: int, lo: int, hi: int) -> int:\n"
"        try:\n"
"            v2 = int(v)\n"
"        except Exception:\n"
"            v2 = lo\n"
"        if v2 < lo:\n"
"            return lo\n"
"        if v2 > hi:\n"
"            return hi\n"
"        return v2\n"
"\n"
"    def _safe_date(y: int, m: int, d: int):\n"
"        try:\n"
"            return date(int(y), int(m), int(d))\n"
"        except Exception:\n"
"            return None\n"
"\n"
"    def _collect_dates(src: str):\n"
"        out = []\n"
"        # YYYY-MM-DD / YYYY/MM/DD / YYYY.MM.DD\n"
"        for m in re.finditer(r'(19\\\\d{2}|20\\\\d{2})\\\\s*[-/\\\\.]\\\\s*(\\\\d{1,2})\\\\s*[-/\\\\.]\\\\s*(\\\\d{1,2})', src):\n"
"            dd = _safe_date(int(m.group(1)), int(m.group(2)), int(m.group(3)))\n"
"            if dd:\n"
"                out.append((m.start(), dd))\n"
"        # Chinese: (YYYY年)?M月D(日/号)?\n"
"        for m in re.finditer(r'(?:(19\\\\d{2}|20\\\\d{2})\\\\s*年\\\\s*)?(\\\\d{1,2})\\\\s*月\\\\s*(\\\\d{1,2})\\\\s*[日号]?', src):\n"
"            yy = m.group(1)\n"
"            if yy:\n"
"                y = int(yy)\n"
"            else:\n"
"                y = int(now.year)\n"
"            dd = _safe_date(y, int(m.group(2)), int(m.group(3)))\n"
"            if dd:\n"
"                out.append((m.start(), dd))\n"
"        out = sorted(out, key=lambda x: x[0])\n"
"        return [x[1] for x in out]\n"
"\n"
"    # (A) next N days / 接下来N天\n"
"    m_nd = re.search(r'(接下来|接下來|未来|未來)\\\\s*(\\\\d{1,2})\\\\s*天', text)\n"
"    if not m_nd:\n"
"        m2 = re.search(r'next\\\\s*(\\\\d{1,2})\\\\s*days', low)\n"
"        if m2:\n"
"            n = _clamp_int(int(m2.group(1)), 1, 10)\n"
"            return {'mode': 'range', 'start_date': base_d, 'days': n, 'label': '接下来' + str(n) + '天'}\n"
"    if m_nd:\n"
"        n = _clamp_int(int(m_nd.group(2)), 1, 10)\n"
"        return {'mode': 'range', 'start_date': base_d, 'days': n, 'label': '接下来' + str(n) + '天'}\n"
"\n"
"    # (B) explicit date or date range\n"
"    ds = _collect_dates(text)\n"
"    if len(ds) >= 1:\n"
"        has_range_word = False\n"
"        for kw in ['到', '至', '~', '-', '—', '–', 'from', 'to', 'between']:\n"
"            if kw in low:\n"
"                has_range_word = True\n"
"                break\n"
"        if has_range_word and len(ds) >= 2:\n"
"            d1 = ds[0]\n"
"            d2 = ds[1]\n"
"            if d2 < d1:\n"
"                d1, d2 = d2, d1\n"
"            n = (d2 - d1).days + 1\n"
"            n = _clamp_int(n, 1, 10)\n"
"            return {'mode': 'range', 'start_date': d1, 'days': n, 'label': str(d1) + '到' + str(d2)}\n"
"        return {'mode': 'single', 'target_date': ds[0], 'label': str(ds[0])}\n"
"\n"
"    # (C) relative days\n"
"    if ('后天' in text) or ('day after tomorrow' in low):\n"
"        return {'mode': 'single', 'target_date': base_d, 'offset': 2, 'label': '后天'}\n"
"    if ('明天' in text) or ('tomorrow' in low):\n"
"        return {'mode': 'single', 'target_date': base_d, 'offset': 1, 'label': '明天'}\n"
"    if ('今天' in text) or ('today' in low):\n"
"        return {'mode': 'single', 'target_date': base_d, 'offset': 0, 'label': '今天'}\n"
"\n"
"    # fallback = today\n"
"    return {'mode': 'single', 'target_date': base_d, 'offset': 0, 'label': '今天'}\n"
"\n"
"def _summarise_weather_item(x: dict) -> str:\n"
"    if not isinstance(x, dict):\n"
"        return '暂无可用的天气预报数据。'\n"
"    cond = str(x.get('condition') or '').strip()\n"
"    t_hi = x.get('temperature')\n"
"    t_lo = x.get('templow')\n"
"    rain = x.get('precipitation')\n"
"    wind = x.get('wind_speed')\n"
"\n"
"    parts = []\n"
"    if cond:\n"
"        parts.append('天气: ' + cond)\n"
"    if (t_hi is not None) or (t_lo is not None):\n"
"        if (t_hi is not None) and (t_lo is not None):\n"
"            parts.append('最高/最低: ' + str(t_hi) + '°C / ' + str(t_lo) + '°C')\n"
"        elif t_hi is not None:\n"
"            parts.append('温度: ' + str(t_hi) + '°C')\n"
"        else:\n"
"            parts.append('最低: ' + str(t_lo) + '°C')\n"
"    if rain is not None:\n"
"        try:\n"
"            rv = float(rain)\n"
"            if rv <= 0:\n"
"                parts.append('预计无降雨')\n"
"            else:\n"
"                parts.append('降雨: ' + str(rain))\n"
"        except Exception:\n"
"            parts.append('降雨: ' + str(rain))\n"
"    if wind is not None:\n"
"        parts.append('有风（约 ' + str(wind) + '）')\n"
"    return '，'.join(parts) if parts else '暂无可用的天气预报数据。'\n"
"\n"
"def _pick_daily_forecast_by_local_date(fc_list: list, target_d: date, tzinfo) -> dict:\n"
"    if not isinstance(fc_list, list) or (len(fc_list) == 0):\n"
"        return None\n"
"    if not isinstance(target_d, date):\n"
"        return fc_list[0] if isinstance(fc_list[0], dict) else None\n"
"\n"
"    best = None\n"
"    for it in fc_list:\n"
"        if not isinstance(it, dict):\n"
"            continue\n"
"        dtx = it.get('datetime')\n"
"        ld = _local_date_from_iso(str(dtx or ''), tzinfo)\n"
"        if ld is None:\n"
"            continue\n"
"        if ld == target_d:\n"
"            best = it\n"
"            break\n"
"    if best is None:\n"
"        best = fc_list[0] if isinstance(fc_list[0], dict) else None\n"
"    return best\n"
"\n"
"def _summarise_weather_range(fc_list: list, start_d: date, days: int, tzinfo) -> str:\n"
"    if not isinstance(fc_list, list) or (len(fc_list) == 0):\n"
"        return '暂无可用的天气预报数据。'\n"
"    try:\n"
"        n = int(days)\n"
"    except Exception:\n"
"        n = 1\n"
"    if n < 1:\n"
"        n = 1\n"
"    if n > 5:\n"
"        n = 5\n"
"\n"
"    out = []\n"
"    for i in range(0, n):\n"
"        d0 = start_d + timedelta(days=i)\n"
"        it = _pick_daily_forecast_by_local_date(fc_list, d0, tzinfo)\n"
"        if it is None:\n"
"            continue\n"
"        mmdd = str(d0.month) + '/' + str(d0.day)\n"
"        out.append(mmdd + ' ' + _summarise_weather_item(it))\n"
"    return '；'.join(out) if out else '暂无可用的天气预报数据。'\n"
+ MARK_HELPER_END + "\n\n"
    )

    s = s[:i] + helpers + s[i:]

# ---------- 2) insert route override block after rt computed (idempotent) ----------
if MARK_ROUTE_BEGIN not in s:
    anchor = "rt = _route_type(user_text)\n"
    i = s.find(anchor)
    if i < 0:
        raise RuntimeError("cannot find anchor: rt = _route_type(user_text)")

    insert_at = i + len(anchor)

    route_block = (
"\n" + MARK_ROUTE_BEGIN + "\n"
"    # Structured weather: support tomorrow / next N days / explicit dates\n"
"    if rt == 'structured_weather':\n"
"        default_weather = (os.environ.get('HA_DEFAULT_WEATHER_ENTITY') or '').strip()\n"
"        if not default_weather:\n"
"            return {\n"
"                'ok': True,\n"
"                'route_type': 'structured_weather',\n"
"                'final': '未配置默认天气实体。请设置环境变量 HA_DEFAULT_WEATHER_ENTITY。',\n"
"                'error': 'missing_default_weather_entity',\n"
"            }\n"
"\n"
"        tzinfo = None\n"
"        try:\n"
"            tzinfo = _now_local().tzinfo\n"
"        except Exception:\n"
"            tzinfo = None\n"
"\n"
"        q = _weather_range_from_text(user_text)\n"
"\n"
"        # fetch daily forecasts\n"
"        r = ha_weather_forecast(default_weather, 'daily', 12)\n"
"        if not r.get('ok'):\n"
"            return {\n"
"                'ok': True,\n"
"                'route_type': 'structured_weather',\n"
"                'final': '我现在联网查询失败了，请稍后再试。',\n"
"                'data': r,\n"
"            }\n"
"\n"
"        fc = r.get('forecast') if isinstance(r.get('forecast'), list) else []\n"
"        label = str((q.get('label') or '')).strip()\n"
"\n"
"        # resolve date(s)\n"
"        now = _now_local()\n"
"        base_d = date(now.year, now.month, now.day)\n"
"\n"
"        if q.get('mode') == 'range':\n"
"            start_d = q.get('start_date')\n"
"            if not isinstance(start_d, date):\n"
"                start_d = base_d\n"
"            days = q.get('days')\n"
"            try:\n"
"                days_i = int(days)\n"
"            except Exception:\n"
"                days_i = 3\n"
"            if days_i < 1:\n"
"                days_i = 1\n"
"            if days_i > 5:\n"
"                days_i = 5\n"
"\n"
"            summary = _summarise_weather_range(fc, start_d, days_i, tzinfo)\n"
"            head = '（' + default_weather + '）'\n"
"            if label:\n"
"                final = head + label + '天气：' + summary\n"
"            else:\n"
"                final = head + '未来' + str(days_i) + '天天气：' + summary\n"
"\n"
"            return {'ok': True, 'route_type': 'structured_weather', 'final': final, 'data': r}\n"
"\n"
"        # single day\n"
"        offset = q.get('offset')\n"
"        try:\n"
"            off = int(offset)\n"
"        except Exception:\n"
"            off = 0\n"
"\n"
"        target_d = q.get('target_date')\n"
"        if isinstance(target_d, date):\n"
"            td = target_d\n"
"        else:\n"
"            td = base_d + timedelta(days=off)\n"
"\n"
"        it = _pick_daily_forecast_by_local_date(fc, td, tzinfo)\n"
"        summary = _summarise_weather_item(it)\n"
"        head = '（' + default_weather + '）'\n"
"        if label:\n"
"            final = head + label + '天气：' + summary\n"
"        else:\n"
"            final = head + '天气：' + summary\n"
"\n"
"        return {'ok': True, 'route_type': 'structured_weather', 'final': final, 'data': r}\n"
+ MARK_ROUTE_END + "\n"
    )

    s = s[:insert_at] + route_block + s[insert_at:]

p.write_text(s, encoding="utf-8")
print("patched_ok=1")
