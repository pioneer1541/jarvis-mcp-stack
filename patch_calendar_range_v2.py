import re
from pathlib import Path

p = Path("app.py")
s = p.read_text(encoding="utf-8")

# ---------- 1) replace _calendar_range_from_text ----------
start_sig = "def _calendar_range_from_text(t: str) -> dict:\n"
i = s.find(start_sig)
if i < 0:
    raise RuntimeError("cannot find function: _calendar_range_from_text")

# function ends right before the next '@mcp.tool' after its start
j = s.find("\n@mcp.tool", i)
if j < 0:
    raise RuntimeError("cannot find end anchor '\\n@mcp.tool' after _calendar_range_from_text")

new_func = (
'def _calendar_range_from_text(t: str) -> dict:\n'
'    # Enhanced: supports explicit dates, date ranges, and "next N days".\n'
'    now = _now_local()\n'
'    text = (t or "")\n'
'    low = text.lower()\n'
'\n'
'    base = datetime(now.year, now.month, now.day, 0, 0, 0, tzinfo=now.tzinfo)\n'
'    start = base\n'
'    end = base + timedelta(days=1)\n'
'    label = ""\n'
'    days = 1\n'
'\n'
'    def _clamp_int(v: int, lo: int, hi: int) -> int:\n'
'        try:\n'
'            v2 = int(v)\n'
'        except Exception:\n'
'            v2 = lo\n'
'        if v2 < lo:\n'
'            return lo\n'
'        if v2 > hi:\n'
'            return hi\n'
'        return v2\n'
'\n'
'    def _safe_date(y: int, m: int, d: int):\n'
'        try:\n'
'            return date(int(y), int(m), int(d))\n'
'        except Exception:\n'
'            return None\n'
'\n'
'    def _collect_dates(src: str):\n'
'        out = []\n'
'        # YYYY-MM-DD / YYYY/MM/DD / YYYY.MM.DD\n'
'        for m in re.finditer(r"(19\\d{2}|20\\d{2})\\s*[-/\\.]\\s*(\\d{1,2})\\s*[-/\\.]\\s*(\\d{1,2})", src):\n'
'            y = int(m.group(1))\n'
'            mo = int(m.group(2))\n'
'            da = int(m.group(3))\n'
'            dd = _safe_date(y, mo, da)\n'
'            if dd:\n'
'                out.append((m.start(), dd))\n'
'\n'
'        # Chinese: (YYYY年)?M月D(日/号)?\n'
'        for m in re.finditer(r"(?:(19\\d{2}|20\\d{2})\\s*年\\s*)?(\\d{1,2})\\s*月\\s*(\\d{1,2})\\s*[日号]?", src):\n'
'            y = m.group(1)\n'
'            if y:\n'
'                yy = int(y)\n'
'            else:\n'
'                yy = int(now.year)\n'
'            mo = int(m.group(2))\n'
'            da = int(m.group(3))\n'
'            dd = _safe_date(yy, mo, da)\n'
'            if dd:\n'
'                out.append((m.start(), dd))\n'
'\n'
'        out = sorted(out, key=lambda x: x[0])\n'
'        return [x[1] for x in out]\n'
'\n'
'    # (A) Next N days / Future N days\n'
'    m_nd = re.search(r"(接下来|接下來|未来|未來)\\s*(\\d{1,2})\\s*天", text)\n'
'    if not m_nd:\n'
'        m_nd = re.search(r"next\\s*(\\d{1,2})\\s*days", low)\n'
'        if m_nd:\n'
'            # align group to be the number\n'
'            n = int(m_nd.group(1))\n'
'            n = _clamp_int(n, 1, 31)\n'
'            start = base\n'
'            end = base + timedelta(days=n)\n'
'            days = n\n'
'            label = "接下来" + str(n) + "天"\n'
'            return {"start": _iso_local(start), "end": _iso_local(end), "label": label, "days": days}\n'
'\n'
'    if m_nd:\n'
'        n = int(m_nd.group(2))\n'
'        n = _clamp_int(n, 1, 31)\n'
'        start = base\n'
'        end = base + timedelta(days=n)\n'
'        days = n\n'
'        label = "接下来" + str(n) + "天"\n'
'        return {"start": _iso_local(start), "end": _iso_local(end), "label": label, "days": days}\n'
'\n'
'    # (B) Explicit date or date range\n'
'    ds = _collect_dates(text)\n'
'    if len(ds) >= 1:\n'
'        has_range_word = False\n'
'        for kw in ["到", "至", "~", "-", "—", "–", "from", "to", "between"]:\n'
'            if kw in low:\n'
'                has_range_word = True\n'
'                break\n'
'\n'
'        if has_range_word and len(ds) >= 2:\n'
'            d1 = ds[0]\n'
'            d2 = ds[1]\n'
'            if d2 < d1:\n'
'                d1, d2 = d2, d1\n'
'            start = datetime(d1.year, d1.month, d1.day, 0, 0, 0, tzinfo=now.tzinfo)\n'
'            end = datetime(d2.year, d2.month, d2.day, 0, 0, 0, tzinfo=now.tzinfo) + timedelta(days=1)\n'
'            days = (d2 - d1).days + 1\n'
'            label = str(d1) + "到" + str(d2)\n'
'            return {"start": _iso_local(start), "end": _iso_local(end), "label": label, "days": days}\n'
'\n'
'        # single day\n'
'        d1 = ds[0]\n'
'        start = datetime(d1.year, d1.month, d1.day, 0, 0, 0, tzinfo=now.tzinfo)\n'
'        end = start + timedelta(days=1)\n'
'        days = 1\n'
'        label = str(d1)\n'
'        return {"start": _iso_local(start), "end": _iso_local(end), "label": label, "days": days}\n'
'\n'
'    # (C) fallback: today/tomorrow/this week/next week\n'
'    if ("tomorrow" in low) or ("明天" in text):\n'
'        start = base + timedelta(days=1)\n'
'        end = start + timedelta(days=1)\n'
'        days = 1\n'
'        label = "明天"\n'
'    elif ("next week" in low) or ("下周" in text):\n'
'        wd = base.weekday()  # Monday=0\n'
'        start = base - timedelta(days=wd) + timedelta(days=7)\n'
'        end = start + timedelta(days=7)\n'
'        days = 7\n'
'        label = "下周"\n'
'    elif ("this week" in low) or ("本周" in text) or ("这周" in text):\n'
'        wd = base.weekday()\n'
'        start = base - timedelta(days=wd)\n'
'        end = start + timedelta(days=7)\n'
'        days = 7\n'
'        label = "本周"\n'
'    else:\n'
'        days = 1\n'
'        label = "今天"\n'
'\n'
'    return {"start": _iso_local(start), "end": _iso_local(end), "label": label, "days": days}\n'
)

s2 = s[:i] + new_func + s[j:]

# ---------- 2) route_request calendar branch: prefer rng["label"] ----------
# Find the label assignment block in structured_calendar branch, inject a few lines before the existing label calculation.
needle = '        # Label: 今天/明天/日期\n        label = ""\n'
pos = s2.find(needle)
if pos < 0:
    raise RuntimeError("cannot find calendar label block in route_request (needle mismatch)")

inject = (
'        # Label priority: use rng label if provided (e.g. 接下来7天 / 2026-02-01到2026-02-10)\n'
'        label = ""\n'
'        try:\n'
'            label2 = str((rng.get("label") if isinstance(rng, dict) else "") or "").strip()\n'
'            if label2:\n'
'                label = label2\n'
'        except Exception:\n'
'            label = ""\n'
'\n'
'        # If no label from range parser, fallback to 今天/明天/日期\n'
)
s2 = s2.replace(needle, inject, 1)

p.write_text(s2, encoding="utf-8")
print("patched_ok=1")
