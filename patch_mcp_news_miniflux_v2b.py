#!/usr/bin/env python3
import os
from datetime import datetime

def _read(p):
    with open(p, "r", encoding="utf-8") as f:
        return f.read()

def _write(p, s):
    with open(p, "w", encoding="utf-8") as f:
        f.write(s)

def _build_new_block():
    L = []
    L.append('@mcp.tool(')
    L.append('    name="news_digest",')
    L.append('    description="(Tool) News digest via Miniflux (RSS). Reads entries from the last 24 hours (rolling 24h). Category-driven; default 5 items. Chinese-first with lightweight topic filtering and fallback."')
    L.append(')')
    L.append('def news_digest(category: str = "world",')
    L.append('               limit: int = 5,')
    L.append('               time_range: str = "24h",')
    L.append('               prefer_lang: str = "zh",')
    L.append('               user_text: str = "",')
    L.append('               **kwargs) -> dict:')
    L.append('    """')
    L.append('    Miniflux-backed news digest.')
    L.append('')
    L.append('    Hard rules:')
    L.append('    - Source of truth: Miniflux (RSS aggregator)')
    L.append('    - Window: last 24 hours (rolling 24h), regardless of time_range input')
    L.append('    - Output: default 5 items, Chinese-first; if not enough, fallback to English')
    L.append('    - Lightweight topic filter to reduce category pollution:')
    L.append('        * blacklist keywords -> drop')
    L.append('        * whitelist keywords (when available) -> keep if hit, otherwise filtered')
    L.append('        * if filtered results not enough -> relax whitelist, then cross-language fill')
    L.append('    """')
    L.append('')
    L.append('    base_url = os.environ.get("MINIFLUX_BASE_URL") or "http://192.168.1.162:19091"')
    L.append('    token = os.environ.get("MINIFLUX_API_TOKEN") or ""')
    L.append('    if not token.strip():')
    L.append('        return {')
    L.append('            "ok": False,')
    L.append('            "error": "MINIFLUX_API_TOKEN is not set",')
    L.append('            "category": category,')
    L.append('            "time_range": "24h",')
    L.append('            "limit": limit,')
    L.append('            "items": [],')
    L.append('            "final": "Miniflux API Token 未配置（MINIFLUX_API_TOKEN）。"')
    L.append('        }')
    L.append('')
    L.append('    def _mf_req(path: str, params: dict = None) -> dict:')
    L.append('        url = base_url.rstrip("/") + path')
    L.append('        headers = {"X-Auth-Token": token}')
    L.append('        try:')
    L.append('            r = requests.get(url, headers=headers, params=(params or {}), timeout=12)')
    L.append('            if int(getattr(r, "status_code", 0) or 0) >= 400:')
    L.append('                return {"ok": False, "status": int(r.status_code), "text": (r.text or "")[:500]}')
    L.append('            return {"ok": True, "data": r.json()}')
    L.append('        except Exception as e:')
    L.append('            return {"ok": False, "error": str(e)}')
    L.append('')
    L.append('    def _strip_html(s: str) -> str:')
    L.append('        if not s:')
    L.append('            return ""')
    L.append('        try:')
    L.append('            s2 = re.sub(r"<[^>]+>", " ", s)')
    L.append('            s2 = html.unescape(s2)')
    L.append('            s2 = re.sub(r"\\s+", " ", s2).strip()')
    L.append('            return s2')
    L.append('        except Exception:')
    L.append('            return (s or "").strip()')
    L.append('')
    L.append('    def _to_local_time(iso_str: str) -> str:')
    L.append('        if not iso_str:')
    L.append('            return ""')
    L.append('        try:')
    L.append('            dt = datetime.fromisoformat(iso_str.replace("Z", "+00:00"))')
    L.append('            tzname = os.environ.get("TZ") or "Australia/Melbourne"')
    L.append('            dt2 = dt.astimezone(ZoneInfo(tzname))')
    L.append('            return dt2.strftime("%Y-%m-%d %H:%M")')
    L.append('        except Exception:')
    L.append('            return iso_str')
    L.append('')
    L.append('    def _has_cjk(s: str) -> bool:')
    L.append('        if not s:')
    L.append('            return False')
    L.append('        try:')
    L.append('            han = 0')
    L.append('            total = 0')
    L.append('            for ch in s:')
    L.append('                oc = ord(ch)')
    L.append('                if ch.isspace():')
    L.append('                    continue')
    L.append('                total += 1')
    L.append('                if (0x4E00 <= oc <= 0x9FFF) or (0x3400 <= oc <= 0x4DBF) or (0x20000 <= oc <= 0x2A6DF):')
    L.append('                    han += 1')
    L.append('            if total <= 0:')
    L.append('                return False')
    L.append('            if han >= 8:')
    L.append('                return True')
    L.append('            return (float(han) / float(total)) >= 0.12')
    L.append('        except Exception:')
    L.append('            return False')
    L.append('')
    L.append('    def _kw_hit(text_s: str, kws: list) -> bool:')
    L.append('        if not text_s:')
    L.append('            return False')
    L.append('        t0 = (text_s or "").lower()')
    L.append('        for k in (kws or []):')
    L.append('            kk = (k or "").strip().lower()')
    L.append('            if not kk:')
    L.append('                continue')
    L.append('            if kk in t0:')
    L.append('                return True')
    L.append('        return False')
    L.append('')
    L.append('    def _norm_title(s: str) -> str:')
    L.append('        s2 = _ug_clean_unicode(s or "")')
    L.append('        s2 = s2.lower()')
    L.append('        s2 = re.sub(r"\\s+", " ", s2).strip()')
    L.append('        return s2')
    L.append('')
    L.append('    cats = _mf_req("/v1/categories")')
    L.append('    if not cats.get("ok"):')
    L.append('        return {"ok": False, "error": "failed to fetch miniflux categories", "detail": cats, "category": category, "time_range": "24h", "limit": limit, "items": [], "final": "Miniflux categories 拉取失败。"}')
    L.append('')
    L.append('    categories = cats.get("data") or []')
    L.append('    key = (category or "").strip()')
    L.append('')
    L.append('    aliases_map = {')
    L.append('        "world": ["world（世界新闻）", "世界新闻", "国际"],')
    L.append('        "cn_finance": ["cn_finance（中国财经）", "中国财经", "财经", "中国经济"],')
    L.append('        "au_politics": ["au_politics（澳洲政治新闻）", "澳洲政治", "澳大利亚政治", "Australian politics"],')
    L.append('        "mel_life": ["mel_life（墨尔本民生）", "墨尔本民生", "维州民生", "Victoria"],')
    L.append('        "tech_internet": ["tech_internet（互联网科技）", "互联网科技", "科技", "Tech"],')
    L.append('        "tech_gadgets": ["tech_gadgets（数码产品）", "数码产品", "评测", "Gadgets"],')
    L.append('        "gaming": ["gaming（电子游戏）", "电子游戏", "游戏", "Gaming"],')
    L.append('    }')
    L.append('')
    L.append('    def _match_cat_id(k: str):')
    L.append('        if not k:')
    L.append('            return None')
    L.append('        for c in categories:')
    L.append('            try:')
    L.append('                title = (c.get("title") or "").strip()')
    L.append('                if title == k:')
    L.append('                    return int(c.get("id"))')
    L.append('            except Exception:')
    L.append('                continue')
    L.append('        for c in categories:')
    L.append('            try:')
    L.append('                title = (c.get("title") or "").strip()')
    L.append('                if title.startswith(k) or (k in title):')
    L.append('                    return int(c.get("id"))')
    L.append('            except Exception:')
    L.append('                continue')
    L.append('        for al in (aliases_map.get(k) or []):')
    L.append('            for c in categories:')
    L.append('                try:')
    L.append('                    title = (c.get("title") or "").strip()')
    L.append('                    if (al in title) or title == al:')
    L.append('                        return int(c.get("id"))')
    L.append('                except Exception:')
    L.append('                    continue')
    L.append('        return None')
    L.append('')
    L.append('    cat_id = _match_cat_id(key)')
    L.append('    if cat_id is None:')
    L.append('        return {"ok": True, "category": key, "time_range": "24h", "limit": limit, "items": [], "final": "Miniflux 中找不到对应分类：{0}".format(key), "query_used": "miniflux categories title match"}')
    L.append('')
    L.append('    FILTERS = {')
    L.append('        "world": {"whitelist": [], "blacklist": ["ufc", "mma", "boxing odds", "celebrity gossip", "porn", "onlyfans"]},')
    L.append('        "cn_finance": {"whitelist": ["财经", "经济", "金融", "股", "a股", "港股", "美股", "债", "基金", "利率", "通胀", "人民币", "央行", "证监", "bank", "stocks", "market", "bond", "yields", "cpi", "gdp"],')
    L.append('                      "blacklist": ["ufc", "mma", "赛后", "足球", "篮球", "综艺", "八卦", "明星", "电影", "电视剧"]},')
    L.append('        "au_politics": {"whitelist": ["parliament", "senate", "house", "election", "labor", "coalition", "liberal", "greens", "albanese", "dutton", "budget", "treasury", "immigration", "visa", "minister", "cabinet", "议会", "选举", "工党", "自由党", "绿党", "预算", "内阁", "移民", "签证"],')
    L.append('                        "blacklist": ["ufc", "mma", "sport", "match preview", "odds", "celebrity"]},')
    L.append('        "mel_life": {"whitelist": ["melbourne", "victoria", "vic", "cbd", "ptv", "metro", "tram", "train", "bus", "police", "fire", "ambulance", "road", "freeway", "yarra", "docklands", "st kilda", "墨尔本", "维州", "本地", "民生", "交通", "电车", "火车", "警方", "火警", "道路"],')
    L.append('                     "blacklist": ["ufc", "mma", "celebrity", "gossip", "crypto shill"]},')
    L.append('        "tech_internet": {"whitelist": ["ai", "openai", "google", "microsoft", "meta", "apple", "amazon", "tiktok", "x.com", "twitter", "github", "open source", "linux", "android", "ios", "cloud", "security", "privacy", "regulation", "chip", "semiconductor", "人工智能", "开源", "网络安全", "隐私", "监管", "芯片", "半导体"],')
    L.append('                         "blacklist": ["ufc", "mma", "crime", "murder", "celebrity", "gossip", "lottery", "horoscope"]},')
    L.append('        "tech_gadgets": {"whitelist": ["review", "hands-on", "launch", "iphone", "ipad", "mac", "samsung", "pixel", "camera", "laptop", "headphones", "oled", "cpu", "gpu", "benchmark", "评测", "上手", "新品", "发布", "开箱", "相机", "手机", "耳机", "笔记本"],')
    L.append('                        "blacklist": ["ufc", "mma", "crime", "celebrity", "gossip"]},')
    L.append('        "gaming": {"whitelist": ["game", "gaming", "steam", "playstation", "ps5", "xbox", "nintendo", "switch", "patch", "update", "dlc", "release", "trailer", "esports", "游戏", "主机", "更新", "补丁", "发售", "预告"],')
    L.append('                   "blacklist": ["ufc", "mma", "boxing", "wwe", "football", "basketball", "cricket", "horse racing"]},')
    L.append('    }')
    L.append('')
    L.append('    import time as _time')
    L.append('    after_ts = int(_time.time()) - 24 * 3600')
    L.append('')
    L.append('    try:')
    L.append('        lim_int = int(limit)')
    L.append('    except Exception:')
    L.append('        lim_int = 5')
    L.append('    if lim_int < 1:')
    L.append('        lim_int = 1')
    L.append('    if lim_int > 10:')
    L.append('        lim_int = 10')
    L.append('')
    L.append('    fetch_lim = lim_int * 6')
    L.append('    if fetch_lim < 20:')
    L.append('        fetch_lim = 20')
    L.append('    if fetch_lim > 80:')
    L.append('        fetch_lim = 80')
    L.append('')
    L.append('    params = {"order": "published_at", "direction": "desc", "limit": fetch_lim, "after": after_ts}')
    L.append('    ent = _mf_req("/v1/categories/{0}/entries".format(cat_id), params=params)')
    L.append('    if not ent.get("ok"):')
    L.append('        return {"ok": False, "error": "failed to fetch entries", "detail": ent, "category": key, "time_range": "24h", "limit": lim_int, "items": [], "final": "Miniflux entries 拉取失败。"}')
    L.append('')
    L.append('    payload = ent.get("data") or {}')
    L.append('    entries = payload.get("entries") or []')
    L.append('    if not entries:')
    L.append('        return {"ok": True, "category": key, "time_range": "24h", "limit": lim_int, "items": [], "final": "暂无符合最近24小时的条目。", "query_used": "miniflux category_id={0} after={1}".format(cat_id, after_ts)}')
    L.append('')
    L.append('    all_items = []')
    L.append('    for e in entries:')
    L.append('        try:')
    L.append('            title = (e.get("title") or "").strip()')
    L.append('            url = (e.get("url") or "").strip() or (e.get("comments_url") or "").strip()')
    L.append('            published_at_raw = (e.get("published_at") or "").strip()')
    L.append('            published_at = _to_local_time(published_at_raw)')
    L.append('            feed = e.get("feed") or {}')
    L.append('            src = (feed.get("title") or "").strip()')
    L.append('            content_plain = _strip_html((e.get("content") or "").strip())')
    L.append('            snippet = content_plain')
    L.append('            if len(snippet) > 180:')
    L.append('                snippet = snippet[:180].rstrip() + "..."')
    L.append('            is_zh = _has_cjk((title or "") + " " + (content_plain or ""))')
    L.append('            all_items.append({')
    L.append('                "title": title,')
    L.append('                "url": url,')
    L.append('                "published_at": published_at,')
    L.append('                "published_at_raw": published_at_raw,')
    L.append('                "source": src,')
    L.append('                "snippet": snippet,')
    L.append('                "is_zh": is_zh,')
    L.append('                "content_plain": content_plain,')
    L.append('            })')
    L.append('        except Exception:')
    L.append('            continue')
    L.append('')
    L.append('    cfg = FILTERS.get(key) or {"whitelist": [], "blacklist": []}')
    L.append('    wl = cfg.get("whitelist") or []')
    L.append('    bl = cfg.get("blacklist") or []')
    L.append('')
    L.append('    def _passes_blacklist(it: dict) -> bool:')
    L.append('        txt = "{0} {1} {2}".format(it.get("title") or "", it.get("snippet") or "", it.get("source") or "")')
    L.append('        return (not _kw_hit(txt, bl))')
    L.append('')
    L.append('    def _passes_whitelist(it: dict) -> bool:')
    L.append('        if not wl:')
    L.append('            return True')
    L.append('        txt = "{0} {1}".format(it.get("title") or "", it.get("snippet") or "")')
    L.append('        return _kw_hit(txt, wl)')
    L.append('')
    L.append('    def _pick(items_in: list, require_wl: bool, need: int, picked: list, seen_titles: set):')
    L.append('        if need <= 0:')
    L.append('            return')
    L.append('        for it in (items_in or []):')
    L.append('            if need <= 0:')
    L.append('                break')
    L.append('            if not isinstance(it, dict):')
    L.append('                continue')
    L.append('            if not _passes_blacklist(it):')
    L.append('                continue')
    L.append('            if require_wl and (not _passes_whitelist(it)):')
    L.append('                continue')
    L.append('            nt = _norm_title(it.get("title") or "")')
    L.append('            if nt and nt in seen_titles:')
    L.append('                continue')
    L.append('            seen_titles.add(nt)')
    L.append('            picked.append(it)')
    L.append('            need -= 1')
    L.append('')
    L.append('    prefer = (prefer_lang or "zh").strip().lower()')
    L.append('    if prefer not in ["zh", "en"]:')
    L.append('        prefer = "zh"')
    L.append('')
    L.append('    zh_items = [x for x in all_items if bool(x.get("is_zh"))]')
    L.append('    en_items = [x for x in all_items if not bool(x.get("is_zh"))]')
    L.append('')
    L.append('    picked = []')
    L.append('    seen = set()')
    L.append('')
    L.append('    if prefer == "zh":')
    L.append('        _pick(zh_items, True, lim_int - len(picked), picked, seen)')
    L.append('        _pick(en_items, True, lim_int - len(picked), picked, seen)')
    L.append('    else:')
    L.append('        _pick(en_items, True, lim_int - len(picked), picked, seen)')
    L.append('        _pick(zh_items, True, lim_int - len(picked), picked, seen)')
    L.append('')
    L.append('    if len(picked) < lim_int:')
    L.append('        if prefer == "zh":')
    L.append('            _pick(zh_items, False, lim_int - len(picked), picked, seen)')
    L.append('            _pick(en_items, False, lim_int - len(picked), picked, seen)')
    L.append('        else:')
    L.append('            _pick(en_items, False, lim_int - len(picked), picked, seen)')
    L.append('            _pick(zh_items, False, lim_int - len(picked), picked, seen)')
    L.append('')
    L.append('    if len(picked) < lim_int:')
    L.append('        for it in all_items:')
    L.append('            if len(picked) >= lim_int:')
    L.append('                break')
    L.append('            nt = _norm_title(it.get("title") or "")')
    L.append('            if nt and nt in seen:')
    L.append('                continue')
    L.append('            seen.add(nt)')
    L.append('            picked.append(it)')
    L.append('')
    L.append('    out_items = picked[:lim_int]')
    L.append('')
    L.append('    lines = []')
    L.append('    for i, it in enumerate(out_items, 1):')
    L.append('        t = it.get("title") or ""')
    L.append('        u = it.get("url") or ""')
    L.append('        src = it.get("source") or ""')
    L.append('        pa = it.get("published_at") or ""')
    L.append('        sn = it.get("snippet") or ""')
    L.append('        lines.append("{0}) {1}".format(i, t))')
    L.append('        meta = []')
    L.append('        if src:')
    L.append('            meta.append(src)')
    L.append('        if pa:')
    L.append('            meta.append(pa)')
    L.append('        if meta:')
    L.append('            lines.append("   [{0}]".format(" | ".join(meta)))')
    L.append('        if sn:')
    L.append('            lines.append("   {0}".format(sn))')
    L.append('        if u:')
    L.append('            lines.append("   {0}".format(u))')
    L.append('')
    L.append('    return {')
    L.append('        "ok": True,')
    L.append('        "category": key,')
    L.append('        "time_range": "24h",')
    L.append('        "limit": lim_int,')
    L.append('        "items": out_items,')
    L.append('        "final": "\\n".join(lines).strip(),')
    L.append('        "query_used": "miniflux category_id={0} after={1} fetch_limit={2}".format(cat_id, after_ts, fetch_lim),')
    L.append('        "stats": {"fetched": len(all_items), "zh_fetched": len(zh_items), "en_fetched": len(en_items), "returned": len(out_items)},')
    L.append('    }')
    L.append('')

    return "\n".join(L) + "\n"

def main():
    path = "app.py"
    if not os.path.exists(path):
        raise SystemExit("app.py not found")

    src = _read(path)

    needle_start = '@mcp.tool(\n    name="news_digest"'
    i = src.find(needle_start)
    if i < 0:
        raise SystemExit("cannot find news_digest block start")

    needle_end = "def _news__norm_host"
    j = src.find(needle_end, i)
    if j < 0:
        raise SystemExit("cannot find news_digest block end (def _news__norm_host)")

    new_block = _build_new_block()

    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    bak = "app.py.bak.news_miniflux_v2b_{0}".format(ts)
    _write(bak, src)

    out = src[:i] + new_block + src[j:]
    _write(path, out)

    print("OK: patched news_digest (miniflux v2b).")
    print("Backup:", bak)
    print("Changed range:", i, j)

if __name__ == "__main__":
    main()
